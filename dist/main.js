/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/battleground.js":
/*!*****************************!*\
  !*** ./src/battleground.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\n\n\n\n\nconst BOT_RADIUS = _constants__WEBPACK_IMPORTED_MODULE_1__[\"BOT_SIZE\"] / 2;\nconst BULLET_RADIUS = _constants__WEBPACK_IMPORTED_MODULE_1__[\"BULLET_SIZE\"] / 2;\n\nconst MIN_X_POS = 0 + BOT_RADIUS;\nconst MIN_Y_POS = 0 + BOT_RADIUS;\nconst MAX_X_POS = _constants__WEBPACK_IMPORTED_MODULE_1__[\"MAP_WIDTH\"] - BOT_RADIUS;\nconst MAX_Y_POS = _constants__WEBPACK_IMPORTED_MODULE_1__[\"MAP_HEIGHT\"] - BOT_RADIUS;\n\nconst NO_ACTION_TIMEOUT = 5;\nconst BATTLE_TIMEOUT = 100;\n\nclass Battleground {\n    constructor() {\n        this.bots = [];\n        this.botActions = [];\n        this.bullets = [];\n        this.onEnd = null;\n        this.winner = null;\n        this.lastActionTime = null;\n        this.lastBotMoveOrShootTime = null;\n        this.lastShootTime = [Date.now(), Date.now()];\n    }\n\n    addBots(bot1, bot2) {\n        this.bots.push(bot1)\n        this.bots.push(bot2)\n    }\n\n    start(onEnd) {\n        console.log(\"Starting battleground\");\n        this.onEnd = onEnd;\n        this.startTime = Date.now();\n        this.lastUpdate = Date.now();\n        this.lastActionTime = Date.now();\n        this.lastBotMoveOrShootTime = Date.now();\n        this.updateBots();\n        this.updateBotsInterval = setInterval(this.updateBots.bind(this), _constants__WEBPACK_IMPORTED_MODULE_1__[\"TICK_TIME\"]);\n        this.updateInterval = setInterval(this.update.bind(this), 10);\n        this.drawInterval = setInterval(this.draw.bind(this), 10);\n    }\n\n    end() {\n        if (!this.onEnd) return;\n\n        clearInterval(this.updateBotsInterval);\n        clearInterval(this.updateInterval);\n        clearInterval(this.drawInterval);\n\n        this.endTime = Date.now();\n        const totalTime = (this.endTime - this.startTime) / 1000;\n        const results = {\n            startTime: this.startTime,\n            endTime: this.endTime,\n            totalTime,\n            winner: this.winner\n        };\n        this.onEnd(results);\n        this.onEnd = null;\n    }\n\n    updateBot(bot, otherBot) {\n        const gameState = {\n            xPos: bot.xPos,\n            yPos: bot.yPos,\n            rotation: bot.rotation,\n            bullets: bot.bullets,\n            otherPlayer: {\n                xPos: otherBot.xPos,\n                yPos: otherBot.yPos,\n                rotation: otherBot.rotation,\n                bullets: otherBot.bullets\n            }\n        }\n        const botActions = bot.update(gameState);\n        return botActions;\n    }\n\n    updateBots() {\n        this.botActions[0] = this.updateBot(this.bots[0], this.bots[1]);\n        this.botActions[1] = this.updateBot(this.bots[1], this.bots[0]);\n        if (this.botDidActions(this.botActions[0])) {\n            this.lastActionTime = Date.now()\n        }\n        if ((Date.now() - this.lastActionTime) / 1000 > NO_ACTION_TIMEOUT) {\n            this.end();\n        }\n        if ((Date.now() - this.lastBotMoveOrShootTime) / 1000 > NO_ACTION_TIMEOUT) {\n            this.end();\n        }\n        if ((Date.now() - this.startTime) / 1000 > BATTLE_TIMEOUT) {\n            this.end();\n        }\n    }\n\n    botDidActions(botActions) {\n        return botActions.dx != 0 || botActions.dy != 0 || botActions.dh != 0 || botActions.ds != 0;\n    }\n\n    botMoved(bot, newXPos, newYPos) {\n        return bot.xPos != newXPos || bot.yPos != newYPos;\n    }\n\n    update() {\n        const delta = (Date.now() - this.lastUpdate) / 1000;\n        const moveSpeedMultiplier = 1000 / _constants__WEBPACK_IMPORTED_MODULE_1__[\"TICK_TIME\"]; // Bots actually move at maxSpeed every 75ms not every 1000ms.\n\n        this.lastUpdate = Date.now();\n\n        for (var i = 0; i < this.bots.length; i++) {\n            const bot = this.bots[i];\n            const botActions = this.botActions[i];\n            const otherBot = i == 0 ? this.bots[1] : this.bots[0];\n\n            const xMovement = Math.max(Math.min(botActions.dx, _constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]), -_constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]) * delta * moveSpeedMultiplier;\n            const yMovement = Math.max(Math.min(botActions.dy, _constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]), -_constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]) * delta * moveSpeedMultiplier;\n            const rotation = Math.max(Math.min(botActions.dh, _constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]), -_constants__WEBPACK_IMPORTED_MODULE_1__[\"MAX_SPEED\"]) * delta * moveSpeedMultiplier;\n\n            const newXPos = Math.min(Math.max(bot.xPos + xMovement, MIN_X_POS), MAX_X_POS);\n            const newYPos = Math.min(Math.max(bot.yPos + yMovement, MIN_Y_POS), MAX_Y_POS);\n\n            if (this.botMoved(bot, newXPos, newYPos) || botActions.ds) {\n                this.lastBotMoveOrShootTime = Date.now();\n            }\n\n            bot.xPos = newXPos;\n            bot.yPos = newYPos;\n            bot.rotation += rotation;\n            if (bot.rotation > 360)  {\n                bot.rotation -= 360;\n            }\n            if (bot.rotation < 0) {\n                bot.rotation += 360;\n            }\n\n            bot.bullets.forEach((bullet) => {\n                const xDistance = _constants__WEBPACK_IMPORTED_MODULE_1__[\"BULLET_SPEED\"] * Math.cos(bullet.rotation * Math.PI / 180) * delta * moveSpeedMultiplier;\n                const yDistance = _constants__WEBPACK_IMPORTED_MODULE_1__[\"BULLET_SPEED\"] * Math.sin(bullet.rotation * Math.PI / 180) * delta * moveSpeedMultiplier;\n                bullet.xPos += xDistance;\n                bullet.yPos += yDistance;\n                if (bullet.xPos > MAX_X_POS || bullet.xPos < 0) {\n                    bullet.dead = true\n                }\n                if (bullet.yPos > MAX_Y_POS || bullet.yPos < 0) {\n                    bullet.dead = true\n                }\n\n                if (Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"distanceBetweenPoints\"])(bullet.xPos, bullet.yPos, otherBot.xPos, otherBot.yPos) < (BULLET_RADIUS + BOT_RADIUS)) {\n                    otherBot.lives -= 1;\n                    // console.log(\"Bot \" + otherBot.id + \" hit! Now has \" + otherBot.lives + \" lives left.\");\n                    if (otherBot.lives <= 0) {\n                        this.winner = bot.id;\n                        return this.end();\n                    }\n                    bullet.dead = true;\n                }\n            });\n\n            bot.bullets = bot.bullets.filter(function (bullet) { return !bullet.dead; });\n            // console.log(\"Bot bullets: \", bot.bullets);\n\n            if (botActions.ds && bot.bullets.length < 5 && (Date.now() - this.lastShootTime[i]) >= _constants__WEBPACK_IMPORTED_MODULE_1__[\"TICK_TIME\"]) {\n                this.lastShootTime[i] = Date.now();\n                let bullet = this.spawnBullet(bot.xPos, bot.yPos, bot.rotation);\n                // console.log(\"Spawning bullet: \", bullet);\n                botActions.ds = false;\n                bot.bullets.push(bullet);\n            }\n        }\n    }\n\n    draw() {\n        var canvas = document.getElementById('battleground');\n        if (canvas.getContext) {\n            var ctx = canvas.getContext('2d');\n            let fillStyle = \"#ddffdd\";\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            this.bots.forEach(function (bot) {\n                const botColor = bot.id == 1 ? \"#ffdddd\" : \"#ddddff\";\n                ctx.fillStyle = botColor;\n                ctx.beginPath();\n                ctx.arc(bot.xPos, bot.yPos, BOT_RADIUS, 0, 2 * Math.PI, false);\n                ctx.fill();\n\n                ctx.strokeStyle = \"#000000\";\n                ctx.lineWidth = 1;\n                ctx.stroke();\n\n                ctx.beginPath();\n                ctx.lineWidth = 3;\n                ctx.moveTo(bot.xPos, bot.yPos);\n                ctx.lineTo(\n                    bot.xPos + (BOT_RADIUS * Math.cos(bot.rotation * Math.PI / 180)),\n                    bot.yPos + (BOT_RADIUS * Math.sin(bot.rotation * Math.PI / 180)),\n                )\n                ctx.stroke();\n                ctx.resetTransform();\n\n                ctx.fillStyle = \"#000000\";\n                if (bot.bullets.length) {\n                    bot.bullets.forEach(function (bullet) {\n                        ctx.beginPath();\n                        ctx.arc(bullet.xPos, bullet.yPos, BULLET_RADIUS, 0, 2 * Math.PI, false);\n                        ctx.fill();\n                    })\n                }\n            });\n        }\n    }\n\n    spawnBullet(xPos, yPos, rotation) {\n        return {\n            xPos,\n            yPos,\n            rotation\n        };\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Battleground);\n\n//# sourceURL=webpack:///./src/battleground.js?");

/***/ }),

/***/ "./src/bot.js":
/*!********************!*\
  !*** ./src/bot.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math.js\");\n/* harmony import */ var _genome__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./genome */ \"./src/genome.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\n\n\n\n\n/* Codespace = {\n    dx, dy, dh, ds, xPos, yPos, rotation, bullets, otherPlayer\n} */\n\nclass Bot {\n    constructor(id) {\n        this.id = id;\n        this.xPos = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER1_START_X\"];\n        this.yPos = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER1_START_Y\"];\n        this.rotation = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER1_START_ROTATION\"];\n        this.bullets = [];\n        this.lives = _constants__WEBPACK_IMPORTED_MODULE_2__[\"STARTING_LIVES\"];\n        this.genome = new _genome__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n        if (this.id > 1) {\n            this.xPos = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER2_START_X\"];\n            this.yPos = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER2_START_Y\"];\n            this.rotation = _constants__WEBPACK_IMPORTED_MODULE_2__[\"PLAYER2_START_ROTATION\"];\n        }\n\n    }\n\n    loadGenome(genome) {\n        this.genome = genome;\n    }\n\n    createOutputObject() {\n        if (this.id == 2) {\n            const randomMethod = Math.floor(Math.random() * 4);\n            switch (randomMethod) {\n                case 0: return this.createRandomOutputObject();\n                case 1: return this.createStandAndShootOutputObject();\n                case 2: return this.createMoveVerticalAndShootOutputObject();\n                default: return this.createSpinAndShootOutputObject();\n            }\n        }\n        // There should be a total of 16 output nodes, 5 bits for each movement / rotation and another bit on if it should shoot or not\n        const neurons = this.genome.neurons;\n        const outputNeurons = neurons.slice(_constants__WEBPACK_IMPORTED_MODULE_2__[\"MAX_NEURONS\"], neurons.length);\n        const outputValues = outputNeurons.map((neuron) => {\n            return neuron.value > 0 ? 1 : 0;\n        });\n\n        // First bit is if it's negative, other 4 bits are 0 -> 15\n        // let dx = outputValues[0] == 0 ? -1 : 1; \n        // dx *= (outputValues[1] * 1 + outputValues[2] * 2 + outputValues[3] * 4 + outputValues[4] * 8);\n        // let dy = outputValues[5] == 0 ? -1 : 1;\n        // dy *= (outputValues[6] * 1 + outputValues[7] * 2 + outputValues[8] * 4 + outputValues[9] * 8);\n        // let dh = outputValues[10] == 0 ? -1 : 1;\n        // dh *=  (outputValues[11] * 1 + outputValues[12] * 2 + outputValues[13] * 4 + outputValues[14] * 8);\n\n        let dx = outputValues[0] == 0 ? -1 : 1;\n        dx *= (outputValues[1] * _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAX_SPEED\"])\n        let dy = outputValues[2] == 0 ? -1 : 1;\n        dy *= (outputValues[3] * _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAX_SPEED\"])\n        let dh = outputValues[4] == 0 ? -1 : 1;\n        dh *= (outputValues[5] * _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAX_SPEED\"])\n\n        return {\n            dx, \n            dy, \n            dh, \n            ds: outputValues[6] \n        }\n    }\n\n    createRandomOutputObject() {\n        return {\n            dx: Math.floor(Math.random() * 30) - 15,\n            dy: Math.floor(Math.random() * 30) - 15,\n            dh: Math.floor(Math.random() * 30) - 15,\n            ds: Math.random() < 0.1\n        }\n    }\n\n    createStandAndShootOutputObject() {\n        return {\n            dx: 0,\n            dy: 0,\n            dh: 0,\n            ds: Math.random() < 0.1\n        }\n    }\n\n    createMoveVerticalAndShootOutputObject() {\n        return {\n            dx: 0,\n            dy: 15 * Math.floor(Math.random() * 2) - 1,\n            dh: 0,\n            ds: Math.random() < 0.05\n        }\n    }\n\n    createSpinAndShootOutputObject() {\n        return {\n            ds: true,\n            dh: 5,\n            dy: this.otherPlayer.yPos - this.yPos,\n            dx: this.otherPlayer.xPos - this.xPos,\n        }\n    }\n\n\n    updateNetwork(inputs) {\n        this.updateBotPosition(inputs.xPos, inputs.yPos, inputs.rotation)\n        this.otherPlayer = inputs.otherPlayer;\n        const translatedPositions = this.translateObjectPositions(inputs.otherPlayer)\n        this.setInputNeurons(translatedPositions);\n        this.drawBrainView(translatedPositions);\n    }\n\n    updateBotPosition(xPos, yPos, rotation) {\n        this.xPos = xPos\n        this.yPos = yPos\n        this.rotation = rotation\n    }\n\n    translateObjectPositions(otherPlayer) {\n        const playerXPos = this.xPos;\n        const playerYPos = this.yPos;\n        const rotationAngle =  Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"degreesToRadians\"])(-this.rotation);\n        const centerPointX = _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_WIDTH\"] / 2;\n        const centerPointY = _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_HEIGHT\"] / 2;\n        const translationMatrix = [_constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_WIDTH\"] - this.xPos, _constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_HEIGHT\"] - this.yPos];\n\n        const otherPlayerRotated = Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"rotateAroundPoint\"])(this.xPos, this.yPos, rotationAngle, [otherPlayer.xPos, otherPlayer.yPos]);\n        const otherPlayerTranslated = Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"translateMatrix\"])(translationMatrix, otherPlayerRotated);\n\n        return {\n            xPos: otherPlayerTranslated[0],\n            yPos: otherPlayerTranslated[1],\n            bullets: otherPlayer.bullets.map((bullet) => {\n                const bulletRotated = Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"rotateAroundPoint\"])(playerXPos, playerYPos, rotationAngle, [bullet.xPos, bullet.yPos]);\n                const bulletTranslated = Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"translateMatrix\"])(translationMatrix, bulletRotated);\n                return {\n                    xPos: bulletTranslated[0],\n                    yPos: bulletTranslated[1]\n                }\n            })\n        }\n    }\n\n    setInputNeurons(translatedPositions) {\n        const neurons = this.genome.neurons;\n        for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_2__[\"INPUT_NEURONS\"]; i++) {\n            neurons[i].value = 0;\n            let currentSquare = {\n                minX: Math.floor(i % _constants__WEBPACK_IMPORTED_MODULE_2__[\"INPUT_WIDTH\"]) * _constants__WEBPACK_IMPORTED_MODULE_2__[\"NN_SQUARE_SIZE\"],\n                maxX: (Math.floor(i % _constants__WEBPACK_IMPORTED_MODULE_2__[\"INPUT_WIDTH\"]) + 1) * _constants__WEBPACK_IMPORTED_MODULE_2__[\"NN_SQUARE_SIZE\"],\n                minY: Math.floor(i / _constants__WEBPACK_IMPORTED_MODULE_2__[\"INPUT_WIDTH\"]) * _constants__WEBPACK_IMPORTED_MODULE_2__[\"NN_SQUARE_SIZE\"],\n                maxY: (Math.floor(i / _constants__WEBPACK_IMPORTED_MODULE_2__[\"INPUT_WIDTH\"]) + 1) * _constants__WEBPACK_IMPORTED_MODULE_2__[\"NN_SQUARE_SIZE\"],\n            }\n            if (translatedPositions.xPos > currentSquare.minX && translatedPositions.xPos < currentSquare.maxX\n                && translatedPositions.yPos > currentSquare.minY && translatedPositions.yPos < currentSquare.maxY) {\n                neurons[i].value = 1;\n            }\n            translatedPositions.bullets.forEach((bullet) => {\n                if (bullet.xPos > currentSquare.minX && bullet.xPos < currentSquare.maxX\n                    && bullet.yPos > currentSquare.minY && bullet.yPos < currentSquare.maxY) {\n                    neurons[i].value = -1;\n                }\n            });\n        }\n    }\n\n\n    /* This gets the current inputs, and makes their input flow down the network\n    to get to the outputs and figure out what output to press */\n    calculateWeights() {\n        this.genome.calculateWeights();\n    }\n\n    drawBrainView(translatedPositions) {\n        var canvas = document.getElementById('bot' + this.id + 'brain');\n        if (canvas.getContext) {\n            var ctx = canvas.getContext('2d');\n            const playerBGColor = this.id == 1 ? \"#ffdddd\" : \"#ddddff\";\n            const playerColor = this.id == 1 ? \"#ff0000\" : \"#0000ff\";\n            const enemyColor = this.id == 1 ? \"#0000ff\" : \"#ff0000\";\n            ctx.fillStyle = playerBGColor;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // Draw player, always in center. \n            ctx.fillStyle = playerColor;\n            const scaledXPos = this.scaleForBrain(_constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_WIDTH\"]);\n            const scaledYPos = this.scaleForBrain(_constants__WEBPACK_IMPORTED_MODULE_2__[\"MAP_HEIGHT\"]);\n            ctx.fillRect(scaledXPos, scaledYPos, _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"], _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"]);\n\n            //Draw other player and objects, translated to how this brain sees them. \n            ctx.fillStyle = enemyColor;\n            const opponentXPos = this.scaleForBrain(translatedPositions.xPos);\n            const opponentYPos = this.scaleForBrain(translatedPositions.yPos);\n            ctx.fillRect(opponentXPos, opponentYPos, _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"], _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"]);\n\n            ctx.fillStyle = \"#000000\";\n            translatedPositions.bullets.forEach((bullet) => {\n                const bulletXPos = this.scaleForBrain(bullet.xPos);\n                const bulletYPos = this.scaleForBrain(bullet.yPos);\n                ctx.fillRect(bulletXPos, bulletYPos, _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"], _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"]);\n            });\n\n        }\n    }\n\n    // Scales a value to display correctly on the brain graph\n    scaleForBrain(value) {\n        // We find the square of the neural network (each are NN_SQUARE_SIZE in width and height)\n        // Place the object in the one it's inside, and then scale based on the size of this brain canvas. \n        return Math.floor(value / _constants__WEBPACK_IMPORTED_MODULE_2__[\"NN_SQUARE_SIZE\"]) * _constants__WEBPACK_IMPORTED_MODULE_2__[\"BRAIN_CANVAS_SCALE\"];\n    }\n\n    update(inputs) {\n        this.updateNetwork(inputs);\n        this.calculateWeights();\n        return this.createOutputObject()\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Bot);\n\n\n//# sourceURL=webpack:///./src/bot.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: MAX_NEURONS, MAP_WIDTH, MAP_HEIGHT, BRAIN_WIDTH, BRAIN_HEIGHT, BRAIN_CANVAS_WIDTH, NN_SQUARE_SIZE, BRAIN_CANVAS_SCALE, INPUT_WIDTH, INPUT_HEIGHT, INPUT_NEURONS, OUTPUT_NEURONS, STARTING_LIVES, TICK_TIME, BOT_SIZE, MAX_SPEED, BULLET_SIZE, BULLET_SPEED, PLAYER1_START_X, PLAYER1_START_Y, PLAYER1_START_ROTATION, PLAYER2_START_X, PLAYER2_START_Y, PLAYER2_START_ROTATION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_NEURONS\", function() { return MAX_NEURONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAP_WIDTH\", function() { return MAP_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAP_HEIGHT\", function() { return MAP_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BRAIN_WIDTH\", function() { return BRAIN_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BRAIN_HEIGHT\", function() { return BRAIN_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BRAIN_CANVAS_WIDTH\", function() { return BRAIN_CANVAS_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NN_SQUARE_SIZE\", function() { return NN_SQUARE_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BRAIN_CANVAS_SCALE\", function() { return BRAIN_CANVAS_SCALE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INPUT_WIDTH\", function() { return INPUT_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INPUT_HEIGHT\", function() { return INPUT_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INPUT_NEURONS\", function() { return INPUT_NEURONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OUTPUT_NEURONS\", function() { return OUTPUT_NEURONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STARTING_LIVES\", function() { return STARTING_LIVES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TICK_TIME\", function() { return TICK_TIME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BOT_SIZE\", function() { return BOT_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_SPEED\", function() { return MAX_SPEED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BULLET_SIZE\", function() { return BULLET_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BULLET_SPEED\", function() { return BULLET_SPEED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER1_START_X\", function() { return PLAYER1_START_X; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER1_START_Y\", function() { return PLAYER1_START_Y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER1_START_ROTATION\", function() { return PLAYER1_START_ROTATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER2_START_X\", function() { return PLAYER2_START_X; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER2_START_Y\", function() { return PLAYER2_START_Y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PLAYER2_START_ROTATION\", function() { return PLAYER2_START_ROTATION; });\nconst MAX_NEURONS = 10e4;\nconst MAP_WIDTH = 1000; \nconst MAP_HEIGHT = 500; \n\n// The brain is 2x the size of the map because the player is centered in the brain \n// so if player is in top left and other in bottom right it needs enough room to show them\nconst BRAIN_WIDTH = MAP_WIDTH * 2; \nconst BRAIN_HEIGHT = MAP_HEIGHT * 2;\n\nconst BRAIN_CANVAS_WIDTH = 400;\n\nconst NN_SQUARE_SIZE = 100;\nconst BRAIN_CANVAS_SCALE = (BRAIN_CANVAS_WIDTH / (BRAIN_WIDTH / NN_SQUARE_SIZE)); \n\nconst INPUT_WIDTH = BRAIN_WIDTH / NN_SQUARE_SIZE;\nconst INPUT_HEIGHT = BRAIN_HEIGHT / NN_SQUARE_SIZE;\nconst INPUT_NEURONS = INPUT_WIDTH * INPUT_HEIGHT;\n\nconst OUTPUT_NEURONS = 7;\n\nconst STARTING_LIVES = 5;\n\nconst TICK_TIME = 75;\n\nconst BOT_SIZE = 36;\nconst MAX_SPEED = 15;\n// export const MOVE_SPEED_MULTIPLIER = 2;\n\nconst BULLET_SIZE = 20;\nconst BULLET_SPEED = 20;\n\nconst PLAYER1_START_X = 36;\nconst PLAYER1_START_Y = 350;\nconst PLAYER1_START_ROTATION = 0;\n\nconst PLAYER2_START_X = 964;\nconst PLAYER2_START_Y = 350;\nconst PLAYER2_START_ROTATION = 180;\n\n\n\n//# sourceURL=webpack:///./src/constants.js?");

/***/ }),

/***/ "./src/genome.js":
/*!***********************!*\
  !*** ./src/genome.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Genome; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"./src/math.js\");\n/* harmony import */ var _innovation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./innovation */ \"./src/innovation.js\");\n\n\n\n\n\n\n\nconst INITIAL_MUTATION_RATE = 1;\n\nconst PARENT2_INNOVATION_GENE_CHANCE = 0.5;\nconst MUTATION_TYPES = ['connections', 'link', 'node', 'enable', 'disable'];\n\nconst MUTATE_CONNECTION_CHANCE = 0.25;\nconst PERTUBE_CHANCE = 0.9;\nconst MUTATE_LINK_CHANCE = 2;\nconst MUTATE_NODE_CHANCE = 0.5;\nconst MUTATE_BIAS_CHANCE = 0.4;\nconst MUTATE_DISABLE_CHANCE = 0.4;\nconst MUTATE_ENABLE_CHANCE = 0.2;\nconst STEP_SIZE = 0.1;\n\nclass Gene {\n    constructor() {\n        this.from = null;\n        this.to = null;\n        this.weight = 0;\n        this.enabled = true;\n        this.innovation = 0;\n    }\n\n    clone() {\n        const gene = new Gene();\n        gene.from = this.from; \n        gene.to = this.to;\n        gene.weight = this.weight;\n        gene.enabled = this.enabled;\n        gene.innovation = this.innovation;\n        return gene;\n    }\n}\n\nclass Neuron {\n    constructor(id) {\n        this.id = id;\n        this.incoming = [];\n        this.value = 0;\n    }\n}\n\nclass Genome {\n    constructor() {\n        this.genes = [];\n        this.neurons = [];\n        this.mutationRates = {\n            connections: MUTATE_CONNECTION_CHANCE,\n            link: MUTATE_LINK_CHANCE,\n            node: MUTATE_NODE_CHANCE,\n            enable: MUTATE_ENABLE_CHANCE,\n            disable: MUTATE_DISABLE_CHANCE,\n            step: STEP_SIZE\n        };\n        this.fitness = 0;\n        this.globalRank = 0;\n        this.initializeNeurons();\n        this.maxNeuron = _constants__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_NEURONS\"];\n        this.totalRounds = 0;\n    }\n\n    load(genome) {\n        this.genes = [];\n        this.mutationRates = genome.getMutationRates()\n\n        genome.genes.forEach((gene) => {\n            this.genes.push(gene.clone());\n        });\n        this.initializeNeurons();\n        this.maxNeuron = genome.maxNeuron;\n    }\n\n    clone() {\n        const clonedGenome = new Genome();\n        this.genes.forEach(function (gene) {\n            clonedGenome.genes.push(gene.clone());\n        });\n\n        clonedGenome.mutationRates = this.getMutationRates();\n\n        return clonedGenome;\n    }\n\n    addFitness(fitness) {\n        this.fitness += fitness;\n    }\n\n    getMutationRates() {\n        return Object.assign({}, this.mutationRates);\n    }\n\n    newInnovation() {\n        return 0;\n    }\n\n    initializeNeurons() {\n        this.neurons = [];\n\n        for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_NEURONS\"]; i++) {\n            this.neurons.push(this.createNeuron(i))\n        }\n\n        for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_0__[\"OUTPUT_NEURONS\"]; i++) {\n            let id = _constants__WEBPACK_IMPORTED_MODULE_0__[\"MAX_NEURONS\"] + i;\n            this.neurons[id] = this.createNeuron(id);\n        }\n\n        this.genes.forEach((gene) => {\n            if (!gene.enabled) return;\n\n            if (this.neurons[gene.to] == null) {\n                this.neurons[gene.to] = new Neuron(gene.to);\n            }\n            this.neurons[gene.to].incoming.push(gene);\n\n            if (this.neurons[gene.from] == null) {\n                this.neurons[gene.from] = new Neuron(gene.from);\n            }\n        });\n    }\n\n    createNeuron(id) {\n        const neuron = new Neuron(id);\n        return neuron;\n    }\n\n    /* Child gets most of its genes from parent1 which is the fittest \n    of the two parents */\n    inheritFromParents(parent1, parent2) {\n        const parent2Innovations = {};\n        for (let i = 0; i < parent2.genes.length; i++) {\n            let gene = parent2.genes[i];\n            parent2Innovations[gene.innovation] = gene;\n        }\n\n        for (let i = 0; i < parent1.genes.length; i++) {\n            let geneParent = parent1;\n            let gene1 = parent1.genes[i];\n            let gene2 = parent2Innovations[gene1.innovation];\n            if (gene2 != null && Math.random() < PARENT2_INNOVATION_GENE_CHANCE && gene2.enabled) {\n                this.genes.push(gene2.clone());\n            } else {\n                this.genes.push(gene1.clone())\n            }\n        }\n        \n        this.maxNeuron = Math.max(parent1.maxNeuron, parent2.maxNeuron);\n        this.mutationRates = parent1.getMutationRates();\n    }\n\n    /* Chance of applying a random mutation to the child based on\n    its mutation rate */\n    mutate() {\n        Object.keys(this.mutationRates).forEach((mutationType) => {\n            const currentRate = this.mutationRates[mutationType];\n            if (Math.random() < 0.5) {\n                this.mutationRates[mutationType] = currentRate * 0.95;\n            } else {\n                this.mutationRates[mutationType] = currentRate * (1 / 0.95);\n            }\n        });\n\n        if (Math.random() < this.mutationRates['connections']) {\n            this.pointMutate();\n        }\n\n        let linkMutations = this.mutationRates['link'];\n        while (linkMutations > 0) {\n            if (Math.random() < linkMutations) {\n                this.linkMutate();\n            }\n            linkMutations -= 1;\n        }\n\n        let nodeMutations = this.mutationRates['node'];\n        while (nodeMutations > 0) {\n            if (Math.random() < nodeMutations) {\n                this.nodeMutate();\n            }\n            nodeMutations -= 1;\n        }\n\n        let enableMutations = this.mutationRates['enable'];\n        while (enableMutations > 0) {\n            if (Math.random() < enableMutations) {\n                this.enableMutate();\n            }\n            enableMutations -= 1;\n        }\n\n        let disableMutations = this.mutationRates['disable'];\n        while (disableMutations > 0) {\n            if (Math.random() < disableMutations) {\n                this.disableMutate();\n            }\n            disableMutations -= 1;\n        }\n    }\n\n    getRandomNeuron(nonInput) {\n        let startingId = nonInput ? _constants__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_NEURONS\"] : 0\n        const pickableNeurons = this.neurons.map((neuron) => {\n            if (neuron.id >= startingId) return neuron;\n            return null;\n        }).filter((n) => { return n != null });\n        const neuronId = pickableNeurons[Math.floor(Math.random() * pickableNeurons.length)].id;\n        return this.neurons[neuronId];\n    }\n\n    getRandomGene() {\n        return this.genes[Math.floor(Math.random() * this.genes.length)];\n    }\n\n    hasSameGene(gene) {\n        const hasGene = this.genes.some(function(g) {\n            if (g.from === gene.from && g.to === gene.to) {\n                return true\n            }\n            return false;\n        });\n        return hasGene;\n    }\n\n    pointMutate() {\n        const step = this.mutationRates.step;\n\n        this.genes = this.genes.map((gene) => {\n            if (Math.random() < PERTUBE_CHANCE) {\n                gene.weight = gene.weight + Math.random() * step * 2 - step;\n            } else {\n                gene.weight = Math.random() * 4 - 2;\n            }\n            return gene;\n        });\n    }\n\n    linkMutate() {\n        // console.log(\"Performing link mutation\");\n        let neuron1 = this.getRandomNeuron(false)\n        let neuron2 = this.getRandomNeuron(true)\n\n        const gene = new Gene()\n        if (neuron1.id < _constants__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_NEURONS\"] && neuron2.id < _constants__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_NEURONS\"]) {\n            // Both input nodes, we can't link these\n            return;\n        }\n\n        if (neuron1.id < neuron2.id) {\n            gene.from = neuron1.id;\n            gene.to = neuron2.id;\n        } else {\n            gene.from = neuron2.id;\n            gene.to = neuron1.id;\n        }\n\n        if (this.hasSameGene(gene)) {\n            // Don't want two links betwen the same pair of neurons\n            return;\n        }\n\n        gene.innovation = _innovation__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getNext();\n        gene.weight = Math.random() * 4 - 2;\n\n        // console.log(\"Inserting new gene: \", gene);\n        this.genes.push(gene);\n    }\n\n    /* Takes a random gene, disables it, then creates a\n    a new neuron with 2 new genes, one gene going to the old genes\n    input and one to the old genes output. */\n    nodeMutate() {\n        // console.log(\"Performing node mutation\");\n        if (this.genes.length == 0) {\n            return;\n        }\n\n        const gene = this.getRandomGene();\n        if (!gene.enabled) {\n            return;\n        }\n        gene.enabled = false;\n\n        this.maxNeuron++;\n        const neuronId = this.maxNeuron;\n\n        const gene1 = gene.clone();\n        gene1.to = neuronId;\n        gene1.weight = 1;\n        gene1.innovation = _innovation__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getNext()\n        gene1.enabled = true;\n        this.genes.push(gene1);\n\n        const gene2 = gene.clone();\n        gene2.from = neuronId;\n        gene2.weight = 1;\n        gene2.innovation = _innovation__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getNext();\n        gene2.enabled = true;\n        this.genes.push(gene2);\n\n        // console.log(\"Inserting new gene1: \", gene1);\n        // console.log(\"Inserting new gene2: \", gene2);\n    }\n\n    enableMutate() {\n        // console.log(\"Performing enableMutate\");\n        if (this.genes.length == 0) return;\n        const gene = this.getRandomGene();\n        // console.log(\"Enabling gene: \", gene);\n        gene.enabled = true;\n    }\n\n    disableMutate() {\n        // console.log(\"Performing disableMutate\");\n        if (this.genes.length == 0) return;\n        const gene = this.getRandomGene();\n        // console.log(\"Disabling gene:\", gene);\n        gene.enabled = false;\n    }\n\n    calculateWeights() {\n        // const neuronsWithValues = this.neurons.filter((n) => n.value != 0).map((n) => n.id);\n        // console.log(\"Neurons with values: \", neuronsWithValues);\n        for (let i = 0; i < this.neurons.length; i++) {\n            let neuron = this.neurons[i];\n            if (!neuron) continue;\n            if (neuron.incoming.length > 0) {\n                let sum = 0;\n            // if (neuron.incoming.length > 0) {\n            //     let incomingNeuronIds = neuron.incoming.map((i) => i.from); \n            //     console.log(\"Incoming neuron Ids: \", incomingNeuronIds);\n            //     let matchingNeurons = incomingNeuronIds.filter((id) => neuronsWithValues.includes(id))\n            //     if (matchingNeurons.length > 0) {\n            //         console.log(\"Found matching ids: \", matchingNeurons);\n            //     }\n            // }\n                for (let j = 0; j < neuron.incoming.length; j++) {\n                    let incoming = neuron.incoming[j];\n                    let other = this.neurons[incoming.from];\n                    sum += incoming.weight * other.value;  \n                }\n                neuron.value = Object(_math__WEBPACK_IMPORTED_MODULE_1__[\"sigmoid\"])(sum);\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack:///./src/genome.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bot */ \"./src/bot.js\");\n/* harmony import */ var _battleground__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./battleground */ \"./src/battleground.js\");\n/* harmony import */ var _trainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trainer */ \"./src/trainer.js\");\n// The main file that will import the battleground and bot and play bots against each other\n\n\n\n\n\nconst trainer = new _trainer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\nbattle();\n\nfunction battle() {\n    // Bot 1 is the one we're training\n    const bot1 = new _bot__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1);\n    bot1.loadGenome(trainer.getRandomGenome());\n\n    // Bot 2 just does random stuff\n    const bot2 = new _bot__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2);\n\n    // const commands = bot.update(inputs);\n\n    const battleground = new _battleground__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\n    battleground.addBots(bot1, bot2);\n    battleground.start((results) => {\n        console.log(\"Battle results: \", results);\n\n        let botFitness = Math.floor(results.totalTime)\n        if (results.winner == 1) {\n            botFitness += bot1.lives * 10;\n            botFitness += 200;\n        }\n        console.log(\"Bot fitness is: \", botFitness);\n        bot1.genome.addFitness(botFitness);\n        bot1.genome.totalRounds++;\n\n        const roundsRemaining = trainer.getTotalRoundsRemaining() \n        console.log(\"Round Complete, \" + roundsRemaining + \" rounds remaining\");\n        if (roundsRemaining <= 0) {\n            trainer.newGeneration();\n        }\n\n        setTimeout(battle);\n    });\n}\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/innovation.js":
/*!***************************!*\
  !*** ./src/innovation.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* This is a singleton class that returns an innovation number for a new gene\nInnovation numbers are used to keep track of genes when they are passed from\nparent to child. When doing child creation only the genes with the same innovation\nnumber from each parent are swapped so that genes are not 'lost' in the creation\nof the child */\n\nclass Innovation {\n    constructor() {\n        this.innovation = 0;\n    }\n\n    getNext() {\n        this.innovation++;\n        return this.innovation;\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Innovation());\n\n//# sourceURL=webpack:///./src/innovation.js?");

/***/ }),

/***/ "./src/math.js":
/*!*********************!*\
  !*** ./src/math.js ***!
  \*********************/
/*! exports provided: distanceBetweenPoints, translateMatrix, rotateMatrix, rotateAroundPoint, degreesToRadians, multiplyMatrixAndPoint, sigmoid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distanceBetweenPoints\", function() { return distanceBetweenPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translateMatrix\", function() { return translateMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateMatrix\", function() { return rotateMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAroundPoint\", function() { return rotateAroundPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degreesToRadians\", function() { return degreesToRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyMatrixAndPoint\", function() { return multiplyMatrixAndPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sigmoid\", function() { return sigmoid; });\n\n\nfunction distanceBetweenPoints(x1, y1, x2, y2) {\n    var a = x1 - x2;\n    var b = y1 - y2;\n    return Math.sqrt(a*a + b*b);\n}\n\nfunction translateMatrix(matrix, point) {\n    const resultX = matrix[0] + point[0];\n    const resultY = matrix[1] + point[1];\n\n    return [resultX, resultY];\n}\n\nfunction rotateMatrix(matrix, point) {\n    const resultX = matrix[0][0] * point[0] + matrix[0][1] * point[1];\n    const resultY = matrix[1][0] * point[0] + matrix[1][1] * point[1];\n\n    return [resultX, resultY];\n}\n\nfunction rotateAroundPoint(pivotX, pivotY, angle, point) {\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n\n    point[0] -= pivotX;\n    point[1] -= pivotY;\n\n    const rotatedX = point[0] * c - point[1] * s;\n    const rotatedY = point[0] * s + point[1] * c;\n\n    const resultX = rotatedX + pivotX;\n    const resultY = rotatedY + pivotY;\n\n    return [resultX, resultY];\n}\n\nfunction degreesToRadians(degrees) {\n    return degrees * Math.PI / 180\n}\n\nfunction multiplyMatrixAndPoint(matrix, point) {\n\n    var x = point[0];\n    var y = point[1];\n    var w = 1;\n    \n    var resultX = (x * matrix[0][0]) + (y * matrix[0][1]) + (w * matrix[0][2]);\n    var resultY = (x * matrix[1][0]) + (y * matrix[1][1]) + (w * matrix[1][2]);\n    \n    return [resultX, resultY];\n}\n\nfunction sigmoid(value) {\n    // return 1 / (1 + Math.pow(Math.E, -value));\n\n    return 2 / (1 + Math.exp(-4.9 * value)) - 1;\n}\n\n//# sourceURL=webpack:///./src/math.js?");

/***/ }),

/***/ "./src/species.js":
/*!************************!*\
  !*** ./src/species.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Species; });\n/* harmony import */ var _genome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./genome */ \"./src/genome.js\");\n\n\n\nconst MAX_STALE_CHECKS = 15;\nconst CROSSOVER_CHANCE = 75;\n\nclass Species {\n    constructor() {\n        this.genomes = [];\n        this.staleness = 0;\n        this.maxFitness = 0;\n        this.averageGlobalRank = 0;\n    }\n\n    // Go through all genomes and remove the unfittest 50%\n    cull() {\n        this.genomes.sort((a, b) => {\n            return b.fitness - a.fitness;\n        });\n\n        const remainingGenomes = Math.ceil(this.genomes.length / 2);\n        console.log(\"Genomes before the cull: \", this.genomes);\n\n        this.genomes = this.genomes.slice(0, remainingGenomes)\n        console.log(\"Genomes after the cull: \", this.genomes);\n    }\n\n    // Go through genomes and check if any have surpassed the \n    // last maxFitness, if none have for MAX_STALE_CHECKS then \n    // this species is stale and should be eliminated\n    checkStale(overallMaxFitness) {\n        let maxFitness = 0;\n\n        this.genomes.forEach(function (genome) {\n            maxFitness = Math.max(maxFitness, genome.fitness);\n        });\n\n        if (maxFitness <= this.maxFitness && maxFitness <= overallMaxFitness) {\n            this.staleness++;\n        } \n\n        this.maxFitness = Math.max(this.maxFitness, maxFitness);\n        return this.staleness > MAX_STALE_CHECKS\n    }\n\n    calculateAverageGlobalRank() {\n        let totalGlobalRank = 0;\n        this.genomes.forEach(function (genome) {\n            totalGlobalRank += genome.globalRank;\n        });\n\n        this.averageGlobalRank = totalGlobalRank / this.genomes.length;\n    }\n\n    createChildren() {\n        const totalChildren = Math.floor(this.breed);\n        for (var i = 0; i < totalChildren; i++) {\n            this.createChild();\n        }\n    }\n\n    createChild() {\n        let child = null;\n        const shouldCreateCrossover = Math.floor(Math.random() * 100) < CROSSOVER_CHANCE;\n        if (shouldCreateCrossover) {\n            const parent1 = this.getRandomGenome();\n            const parent2 = this.getRandomGenome();\n\n            child = new _genome__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            if (parent1.fitness > parent2.fitness) {\n                child.inheritFromParents(parent1, parent2);\n            } else {\n                child.inheritFromParents(parent2, parent1);\n            }\n\n            child.mutate();\n        } else {\n            child = this.cloneRandomGenome();\n        }\n\n        child.initializeNeurons();\n        this.genomes.push(child);\n    }\n\n    getRandomGenome() {\n        const choice = Math.floor(Math.random() * this.genomes.length);\n        return this.genomes[choice];\n    }\n\n    cloneRandomGenome() {\n        return this.getRandomGenome().clone();\n    }\n}\n\n//# sourceURL=webpack:///./src/species.js?");

/***/ }),

/***/ "./src/trainer.js":
/*!************************!*\
  !*** ./src/trainer.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Trainer; });\n/* harmony import */ var _species__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./species */ \"./src/species.js\");\n/* harmony import */ var _genome__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./genome */ \"./src/genome.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n/**\n * The trainer holds all the species and genomes inside those species. \n * It handles keeping track of the fitnesses of each genome, eliminating those that \n * are unfit, saving and loading genomes to disk etc. \n */\n\n\n\n\n\nconst INITIAL_SPECIES = 10;\nconst INITIAL_GENOMES_PER_SPECIES = 5;\nconst POPULATION = 100;\n\nconst ROUNDS_PER_GENOME = 1;\n\nclass Trainer {\n    constructor() {\n        this.maxFitness = 0;\n        this.species = []\n        this.initializeSpecies();\n    }\n\n    initializeSpecies() {\n        for (var i = 0; i < INITIAL_SPECIES; i++) {\n            let species = new _species__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n            for (var j = 0; j < INITIAL_GENOMES_PER_SPECIES; j++) {\n                let genome = this.createNewGenome();\n                species.genomes.push(genome);\n            }\n            this.species.push(species);\n        }\n    }\n\n    createNewGenome() {\n        const genome = new _genome__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        genome.mutate();\n        genome.initializeNeurons();\n        return genome;\n    }\n\n    /* Returns a random genome that hasn't had enough battles yet. \n    Genomes each do ROUNDS_PER_GENOME battles to determine their fitness\n    */\n    getRandomGenome() {\n        let genome = null;\n        while (genome == null || genome.totalRounds >= ROUNDS_PER_GENOME) {\n            genome = this.getRandomSpecies().getRandomGenome();\n        }\n        console.log(\"New Genome genes: \", genome.genes);\n        return genome;\n    }\n\n    getRandomSpecies() {\n        return this.species[Math.floor(Math.random() * this.species.length)];\n    }\n\n    /* Go through each species, eliminate all below average genomes in the species */\n    cullSpecies() {\n        this.species.forEach((species) => {\n            species.cull();\n        });\n    }\n\n    rankGenomesGlobally() {\n        const allGenomes = [];\n        this.species.forEach((species) => {\n            species.genomes.forEach((genome) => {\n                allGenomes.push(genome);\n            });\n        });\n\n        allGenomes.sort((a, b) => {\n            return a.fitness - b.fitness;\n        });\n\n        // Global rank is from 1 = worst to allGenomes.length = best\n        for (var i = 0; i < allGenomes.length; i++) {\n            allGenomes[i].globalRank = i;\n        }\n\n    }\n\n    removeStaleSpecies() {\n        this.species = this.species.filter((species) => {\n            let isStale = species.checkStale(this.maxFitness);\n            return !isStale;\n        });\n    }\n\n    calculateGlobalMaxFitness() {\n        this.maxFitness = this.species.reduce((maxFitness, species) => {\n            return Math.max(maxFitness, species.maxFitness || 0);\n        }, this.maxFitness)\n        console.log(\"Global max fitness is now: \", this.maxFitness);\n    }\n\n    calculateSpeciesAverageGlobalRank() {\n        this.species.forEach((species) => {\n            species.calculateAverageGlobalRank()\n        });\n    }\n\n    removeWeakSpecies() {\n        let totalAverageGlobalRank = 0;\n        this.species.forEach((species) => {\n            totalAverageGlobalRank += species.averageGlobalRank;\n        });\n\n        console.log(\"Removing weak species. TAGR: \", totalAverageGlobalRank, \" species: \", this.species);\n\n        this.species = this.species.map(function(species) {\n            species.breed = Math.floor((species.averageGlobalRank / totalAverageGlobalRank) * POPULATION);\n            return species;\n        }).filter(function (species) {\n            return species.breed >= 1;\n        });\n    }\n\n    createChildren() {\n        this.species.forEach(function (species) {\n            species.createChildren();\n        });\n    }\n\n\n    newGeneration() {\n        this.cullSpecies();\n        this.rankGenomesGlobally();\n        this.removeStaleSpecies();\n        this.calculateGlobalMaxFitness();\n        this.rankGenomesGlobally();\n        this.calculateSpeciesAverageGlobalRank();\n        this.removeWeakSpecies();\n        this.createChildren();\n        console.log(\"New generation is: \", this.species);\n    }\n\n    getTotalRoundsRemaining() {\n        let totalRoundsRemaining = 0;\n        this.species.forEach(function(species) {\n            species.genomes.forEach(function(genome) {\n                totalRoundsRemaining += ROUNDS_PER_GENOME - genome.totalRounds;\n            })\n        });\n        return totalRoundsRemaining;\n    }\n\n}\n\n//# sourceURL=webpack:///./src/trainer.js?");

/***/ })

/******/ });